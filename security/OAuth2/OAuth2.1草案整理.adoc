= OAuth2.1草案整理
:sectnums:
:chapter-signifier: 章节
:scripts: cjk
:toc:
:toc-title: 目录
:toclevels: 3
:doctype: book
:experimental:

== 简介
OAuth2.1官方地址
https://datatracker.ietf.org/doc/draft-ietf-oauth-v2-1/[OAuth2.1草案]，目前是2024年05月出的第11版为最新版

词汇
[cols="1,1,",options="header"]
|===
|英文|中文|备注
|ABNF|扩展巴科斯范式|Augmented Backus-Naur Form
|authentication|身份认证|
|authorization|授权|
|credential|凭证|
|credentials|证书|
|end-user|最终用户|最终使用软件、系统或服务的用户
|PKCE|最终用户|Proof-Key for Code Exchange
|resource owner|资源所有者|通常指的是最终用户本人
|===

OAuth将授权层引入到客户端-服务器授权模式，将客户端与资源所有者(resource owner)的角色分开。在OAuth中，客户端的请求访问被资源所有者控制，托管于资源服务器。

而不是用资源所有者的证书去访问受保护的资源，客户端获得代表访问属性集(例如范围、生命周期)的凭证，即 `Access Token` 。 `Access Token` 经过资源所有者同意后被授权服务器颁发给客户端。客户端使用这个 `Access Token` 访问托管在资源服务器上受保护的资源。

这种旧的客户端-服务器身份认证模式有太多的限制，客户端使用资源所有者的证书，在服务器上进行身份认证，然后请求一个访问受限的资源(受保护的资源)。为了向应用程序提供受限的资源，资源所有者要分享他们的证书给应用程序。这产生了一些问题和限制:

* 应用程序必须存储资源所有者的证书以供未来使用，通常用明文密码
* 服务器必须支持密码身份认证，尽管密码固有的安全问题
* 应用程序获得了过宽的访问资源所有者资源的权限，使得资源所有者没有能力限制持续时间或访问一些子集资源
* 资源所有者经常与其它无关服务复用密码，尽管用了最安全的措施。这意味着在完全无关的服务中有一个服务被攻击或被曝光了就有安全隐患
* 资源所有者只能撤销所有第三方应用程序的访问权限，而不能只单独撤销一个。而且必须改变资源所有者的密码
* 最终应用程序的泄露将会导致最终用户的密码与该密码保护的所有数据的泄露

在OAuth中，最终用户(资源所有者)可以授权一个打印程序(客户端)访问他们存储在照片共享服务(资源服务器)中受保护的照片，而无需分享用户名和密码给打印程序。相反，他们直接在被照片分享服务信任的服务器(授权服务器)中进行身份认证，颁发特定委托证书( `Access Token` )给打印服务

这种关注点分离提供了更多高级用户身份认证的方法，例如多因素身份认证、密码身份认证，而不需修改应用程序。所有用户通过授权服务器进行身份认证逻辑处理，而应用程序无需关注实现特定的身份认证机制。这让授权服务器可以管理用户身份认证的策略，甚至在未来改变他们不用去协调改变应用程序

授权层也可以简化资源服务器确定请求是否被授权。传统上，在对客户端进行身份认证之后，调用每一个API的时候，每个资源服务器都会计算客户端是否被授权来评估策略。在分布式系统中，这些策略需要同步到所有的资源服务器，或者资源服务器必须调用一个中央策略服务器去处理每一个请求。而在OAuth中，策略的评估仅仅在授权服务器创建一个新的 `Access Token` 的时候被执行。如果授权访问表示在 `Access Token` 中，资源服务器不再需要评估这些策略，而只需要验证这个 `Access Token` 。这种简化适用于当应用程序代表资源所有者或者应用程序自己的时候

OAuth是一个授权协议，而不是一个身份认证的协议。 `Access Token` 表示给客户端授了权。通常客户端发送 `Access Token` 给一个专门的API，该API返回一个用户ID给资源所有者，然后客户端用这个API返回的结果作为代理认证这个用户。此做法并不是OAuth标准或安全注意事项的一部分，可能不考虑由资源所有者提供。实现者在采用这种做法之前，请注意查阅资源服务器的文档。

这个规范设计使用HTTP([RFC9110])。除了HTTP协议的任何协议都超出了OAuth使用的范围。

=== 角色
OAuth定义了4种角色:

. 资源所有者: 能够授权访问受保护资源的实体。当资源所有者是人的时候，称为最终用户。缩写为 "RO"
. 资源服务器: 托管受保护资源的服务器，能够接收用 `Access Token` 的请求和响应受保护资源。通常通过API的方式访问。缩写为 "RS"
. 客户端: 代表资源所有者请求受保护资源的一个应用程序，这个术语并不涵盖任何具体实现的特征(例如，应用程序在服务器、桌面或其它设备执行)
. 授权服务器: 在认证资源所有者与获得授权成功后，这个服务器颁发 `Access Token` 给客户端。缩写为 "AS"

本规范的大部分内容宣言了客户端与授权服务器，以及客户端与资源服务器的交互。

在授权服务器与资源服务器之间的交互超越了本规范的范围，然而，为提供在资源服务器与授权服务器之间协同工作能力的一个选项，几个扩展已被定义。授权服务器可以是一个资源服务器，或者是一个单体。一个单体授权服务器可以颁发 `Access Token` 被多个资源服务器接收。

在资源所有者与授权服务器之前的交互(例如，最终用户在授权服务器上认证自己)也是超出了本规范的范围，有一些例外，例如安全注意事项关于提示征求最终用户的同意。

当资源所有者是最终用户的时候，用户将用客户端交互。当客户端是一个基于WEB的应用程序的时候，用户将通过浏览器([RFC9110]3.5节)与客户端交互。当客户端是一个本地应用的时候，用户将直接通过操作系统与客户端交互。更多详情请查看 https://datatracker.ietf.org/doc/draft-ietf-oauth-v2-1/[草案^]的 2.1 节。

=== 协议流程
  +--------+                               +---------------+
  |        |--(1)------- 请求授权 --------->|      资源      |
  |        |                               |     所有者     |
  |        |<-(2)------- 授权许可 ----------|               |
  |        |                               +---------------+
  |        |
  |        |                               +---------------+
  |        |--(3)------- 授权许可 --------->|       授权     |
  | 客户端  |                               |      服务器    |
  |        |<-(4)-------  `Access Token`  ----------|               |
  |        |                               +---------------+
  |        |
  |        |                               +---------------+
  |        |--(5)--------  `Access Token`  -------->|       资源     |
  |        |                               |      服务器    |
  |        |<-(6)------- 受保护的资源 -------|               |
  +--------+                               +---------------+

                    图 1: 抽象协议流程

图1中抽象OAuth2.1流程插图描述了4个角色之间的交互，包含如下步骤:

. 客户端从资源所有者请求授权。授权请求可以直接发向资源所有者(如图所示)，或者最好是通过授权服务器作为中介间接发出
. 客户端接收到授权许可(代表资源所有者授权的凭证)，表示使用了在本规范中定义的授权许可类型中的一个，或者使用了一个扩展的许可类型。这个授权许可类型取决于客户端请求授权的方法以及授权服务器所支持的类型
. 客户端请求获得 `Access Token` (该令牌通过授权服务器进行认证并且代表授权许可)
. 授权服务器认证客户端且难授权许可，如果有效，颁发 `Access Token`
. 客户端从资源服务器请求受保护资源，出示 `Access Token` 进行认证
. 资源服务器验证访问信息，如果有效，为请求提供服务

为了客户端从资源所有者获得授权许可(第1，2步的描述)的首选方法，是以授权服务器为中介，详情请查看 https://datatracker.ietf.org/doc/draft-ietf-oauth-v2-1/[草案^]的 4.1 节的图3。

=== 授权许可
一个授权许可代表资源所有者的授权(访问他受保护的资源)通过客户端获取 `Access Token` 被使用。本规范定义了3种许可类型: 授权码，刷新令牌和客户端证书，也有定义附加类型的扩展机制。

==== 授权码
授权码用来获取 `Access Token` 的临时凭证。而不是客户端直接从资源所有者请求授权，客户端引导资源所有者去授权服务器(通过浏览器)转过来引导资源所有者带授权码返回客户端。然后，客户端可以交换授权码获取 `Access Token` 。

在引导资源所有者带授权码返回客户端之前，授权服务器认证资源所有者，可以请求资源所有者的同意，或者其它方式告知他们客户端的请求。因为资源所有者只能用授权服务器认证，所以资源所有者的证书永远不会分享到客户端，且客户端不需要了解任何附加认证的步骤，如多因素身份认证或委托账户。

授权码提供了一些重要的安全优势，如认证客户端的能力，以及直接向客户端传送 `Access Token` ，而没有通过资源所有者的浏览器，这可能暴露它给其他人，包括资源所有者。

==== 刷新令牌
刷新令牌是用来获取 `Access Token` 的证书。刷新令牌可以被授权服务器颁发给客户端，在当前 `Access Token` 失效或过期的时候，用来获取新的 `Access Token` ，或者获取额外的一样或有限范围的 `Access Token` (此 `Access Token` 可以比被资源所有者授权具有更短的生命周期和更少的特权)。颁发刷新令牌是由授权服务器自行决定的选项，可以基于客户端属性、请求属性、授权服务器策略或其它任何条件。授权服务器在颁发 `Access Token` 的时候包含了刷新令牌(如 图2 的 第2步)。

刷新令牌是一个代表资源所有者授权许可给客户端的字符串。这个字符串被考虑为对客户端是不透明的。刷新令牌可以是一个用来限制授权信息的识别器，或将此自身信息编码进字符串。不像 `Access Token` ，刷新令牌只能用于授权服务器，而不会发送给资源服务器。

  +--------+                                           +---------------+
  |        |--(1)------------- 授权许可 --------------->|               |
  |        |                                           |               |
  |        |<-(2)-------------  `Access Token`  ----------------|               |
  |        |                 与 刷新令牌                 |               |
  |        |                                           |               |
  |        |                            +----------+   |               |
  |        |--(3)------  `Access Token`  ------->|          |   |               |
  |        |                            |          |   |               |
  |        |<-(4)----- 受保护的资源 ------|    资源   |   |      授权     |
  | 客户端  |                            |   服务器  |   |      服务器    |
  |        |--(5)------  `Access Token`  ------->|          |   |               |
  |        |                            |          |   |               |
  |        |<-(6)----- 令牌失效错误 ------|          |   |               |
  |        |                            +----------+   |               |
  |        |                                           |               |
  |        |--(7)------------- 刷新令牌 --------------->|               |
  |        |                                           |               |
  |        |<-(8)-------------  `Access Token`  ----------------|               |
  +--------+               与 刷新令牌(可选)             +---------------+

                              图 2: 刷新过期的 `Access Token`

图 2 的插图包括如下步骤:

. 客户端请求经授权服务器认证，表示授权许可的 `Access Token`
. 授权服务器认证客户端且校验授权许可，如果有效，颁发 `Access Token` 与刷新令牌(可选)
. 客户端通过已有的 `Access Token` 向资源服务器请求受保护的资源
. 资源服务器校验 `Access Token` ，如果有效，给请求提供服务
. 重复 第3步 到 第4步，直到 `Access Token` 过期。 如果客户端知道 `Access Token` 过期，那么跳到 第7步；否则，继续请求受保护的资源
. 如果 `Access Token` 失效，资源服务器返回令牌失效错误
. 客户端通过已有的刷新令牌和客户端认证(如果已经颁发证书)请求新的 `Access Token` 。客户端认证需要基于客户端类型和授权服务器策略
. 授权服务器认证客户端与校验刷新令牌，如果有效，颁发新的 `Access Token` 与新的刷新令牌(可选)

==== 客户端证书
客户端证书或其他形式的客户端认证(例如，一个用于 JWT 签名的私钥，见[RFC7523])，当授权范围受限于客户端控制下的，或者授权服务器事先安排的受保护资源的时候，能被用于授权许可。客户端证书用于当客户端基于授权服务器事先安排的认证，请求访问受保护资源的时候。

===  `Access Token`
 `Access Token` 是用于访问受保护资源的证书。一个 `Access Token` 是一个代表颁发给客户端的认证的字符串。

该字符串被考虑为对客户端是不透明的，即使有结构。客户端不要期望能解析 `Access Token` 。授权服务器不需要使用一致的 `Access Token` 编码或资源服务器期望的其它格式。

 `Access Token` 代表访问的特定范围和持续时间，由资源服务器授予，被资源服务器和授权服务器强制执行。

依赖授权服务器的实现，令牌字符串可以被资源服务器限制授权信息，或者信息可以在验证方式里面自包含授权信息(一个令牌字符串由已签名的数据有效负载组成)。令牌限制机制的一个示例是 Token Introspection [RFC7662]，资源服务器在授权服务器校验客户端已有令牌时调用端点。结构化令牌格式的一个示例是 JWT Profile for Access Tokens [RFC9068]，用 JWT 编码和签名 `Access Token` 数据的方法。

。。。。

====  `Access Token` 范围
 `Access Token` 颁发给客户端，比用户许可访问具有更少的特权。这被称为有限范围 `Access Token` 。授权服务器与资源服务器能用这个范围机制限制资源的类型或访问特定客户端的级别。

示例，客户端只读访问用户的资源，但是不能更新资源，所以这个客户端可以请求授权服务器中定义的 “只读” 范围，获取的 `Access Token` 不能用于更新资源。这需要协调授权服务器、资源服务器与客户端。提供客户端请求特定范围能力的授权服务器，以 `Access Token` 关联一些范围颁发给客户端。然后，当表现为受限范围 `Access Token` 的时候，资源服务器可响应强制的范围。

OAuth 并没有定义任何的范围，而是在授权服务器、扩展或者是 OAuth 配置文件中定义。例如[OpenID]就是一个这样的扩展，它定义了提供颗粒度访问用户配置文件信息的范围集。最好不要定义与已知扩展冲突的自定义范围。

请求受限范围 `Access Token` ，在认证或令牌端点，客户端使用范围请求参数，

。。。。

==== 持有者令牌
持有者令牌是一种安全令牌，具有任何一方持有令牌(持有者)，可以在持有此令牌的其它方以任何方式使用令牌。使用持有者令牌不需要持有者证明持有加密密钥材料(持有者证明)

。。。。

==== 发送者-受限 `Access Token`
发送者-受限 `Access Token` 将 `Access Token` 的使用绑定到特定的发送者。这个发送者有义务证明其知晓某个秘密的先决条件是接受接收方(如资源服务器)的 `Access Token` 。

。。。。

=== 通讯安全
。。。。

OAuth URL 必须使用 HTTPS 方式，环回网路除外。重定向的 URI 可以是 HTTP 方式。当使用 HTTPS 的时候，TLS 证书必须依据[RFC9110]进行校验。当前 TLS 的最新版本是 1.3[RFC8446]。

。。。。

=== HTTP 重定向
。。。。

=== 互操作性
。。。。

=== 与 OAuth 2.0 的兼容性
。。。。

=== 符号约定
。。。。

== 客户端注册
。。。。

=== 客户端类型
。。。。

=== 客户端标识符
。。。。

客户端标识符是一个不透明的字符串，其大小本规范未做定义。客户端需避免假设标识符的大小。授权服务器应该记录它颁发的任何标识符的大小。

。。。。

=== 客户端重定向端点
。。。。

==== 注册要求
。。。。

==== 多个重定向 URI
。。。。

==== 防止 CSRF 攻击
。。。。

==== 防止混淆攻击
。。。。

==== 无效端点
。。。。

==== 端点内容
。。。。

=== 客户端身份认证
。。。。

==== 客户端机密
为了支持持有客户端机密的客户端，授权服务器必须支持包含客户端证书的客户端在请求的 Body 里面使用下面的参数:

* client_id: 必填项。在注册过程阶段颁发给客户端的客户端标识符(详风第 3.2 节)
* client_secret: 必填项。客户端机密

参数只能在请求内容中传输且不能出现在请求的 URI 中。

示例，请求刷新 `Access Token` (5.3 节)使用内容参数(加了额外的换行符只为显示)

[source,text]
----
POST /token HTTP/1.1
Host: server.example.com
Content-Type: application/x-www-form-urlencoded

grant_type=refresh_token&refresh_token=tGzv3JOkF0XG5Qx2TlKWIA
&client_id=s6BhdRkqt3&client_secret=7Fjfp0ZBr1KtDRbnfVdmIw
----

授权服务器可以支持 HTTP 基础认证方案以认证被颁发客户端机密的客户端。HTTP 基础认证方案在[RFC9110]第 11 节中定义，当授权服务器使用该方案认证的时候，客户端标识符使用 `application/x-www-form-urlencoded` 编码算法(附录 B)进行编码，且编码的值用作用户名称；客户端机密用相同算法进行编码作为密码。

示例(加了额外的换行符只为显示)
[source,text]
----
Authorization: Basic czZCaGRSa3F0Mzo3RmpmcDBaQnIxS3REUmJuZlZkbUl3
----

。。。。

==== 其他身份验证方法
。。。。

==== 未注册的客户端
。。。。

== 协议端点
授权过程利用两个授权服务器端点(HTTP 资源):

* 授权端点: 被客户端用来通过浏览器重定向从资源所有者获取授权
* 令牌端点: 被客户端用来为 `Access Token` 交换认证许可，通常与客户端认证一起

以及一个客户端端点:

* 重定向端点: 被授权服务器用来通过资源所有者浏览器返回包含授权证书的响应给客户端。

并非所有授权许可类型都会利用这两个端点。扩展许可类型或许会定义额外需要的端点。

=== 授权端点
。。。。

=== 令牌端点
。。。。

==== 客户端身份认证
。。。。

==== 令牌请求
。。。。

==== 令牌响应
。。。。

==== 错误响应
。。。。

== 许可类型
。。。。

=== 授权码许可
。。。。

  +----------+
  |    资源   |
  |   所有者  |
  +----------+
        ^
        |
        |
  +-----|----+              客户端标识符         +---------------+
  | .---+---------(1)--- 与 重定向 URI --------->|              |
  | |   |    |                                 |               |
  | |   '---------(2)-------- 用户认证 -------->|               |
  | | 浏览器  |                                 |      授权      |
  | |        |                                 |     服务器     |
  | |        |                                 |               |
  | |    .--------(3)-------- 授权码 ----------<|               |
  +-|----|---+                                 +---------------+
    |    |                                         ^      v
    |    |                                         |      |
    ^    v                                         |      |
  +---------+                                      |      |
  |         |>---(4)------- 授权码 -----------------'      |
  |  客户端  |            与 重定向 URI                     |
  |         |                                             |
  |         |<---(5)-------  `Access Token`  ----------------------'
  +---------+            与 刷新令牌(可选)

                        图 3: 授权码流程

。。。。

==== 授权请求
。。。。

code_verifier 是一个为每一个授权请求生成的高熵加密且随机的字符串，未保留的字符集为: [A-Z] / [a-z] / [0-9] / "-" / "." / "_" / "~"，长度为 43-128。

。。。。

==== 授权响应
。。。。

===== 错误响应
。。。。

==== 令牌端点扩展
。。。。

=== 客户端证书许可