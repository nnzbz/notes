= SSL与TLS协议
:scripts: cjk
:toc: left
:toc-title: 目录
:toclevels: 4

== 历史发展
. 1994年，NetScape公司设计了SSL协议（Secure Sockets Layer）的1.0版，但是未发布。
. 1995年，NetScape公司发布SSL 2.0版，很快发现有严重漏洞。
. 1996年，SSL 3.0版问世，得到大规模应用。
. 1999年，互联网标准化组织ISOC接替NetScape公司，发布了SSL的升级版TLS 1.0版。
. 2006年和2008年，TLS进行了两次升级，分别为TLS 1.1版和TLS 1.2版。最新的变动是2011年TLS 1.2的修订版。

目前(2014年)，应用最广泛的是TLS 1.0，接下来是SSL 3.0。但是，主流浏览器都已经实现了TLS 1.2的支持。

TLS 1.0通常被标示为SSL 3.1，TLS 1.1为SSL 3.2，TLS 1.2为SSL 3.3。

== 基本过程

. 客户端向服务器端索要并验证(放入数字证书中的)公钥(非对称加密算法)
. 双方协商生成 *对话密钥*(对称加密算法，加解密速度比非对称算法快)
. 双方采用 *对话密钥* 进行加密通信

****
* 前2步又称为 *握手阶段(handshake)*
* 非对称加密算法仅用于 *握手阶段*，而 *对话密钥* 则第3步通信的时候则使用 *对话密钥* 进行加解密，这样可减少运算消耗时间
****

== 握手阶段详细过程
image::握手阶段详细过程.png[]
. 客户端发出请求（ClientHello）
+
.请求的内容
****
* 支持的协议版本，比如TLS 1.0版
* 一个客户端生成的随机数，稍后用于生成"对话密钥"
* 支持的加密方法，比如RSA公钥加密
* 支持的压缩方法
****
+
* 这里需要注意的是，客户端发送的信息之中不包括服务器的域名。也就是说，理论上服务器只能包含一个网站，否则会分不清应该向客户端提供哪一个网站的数字证书。这就是为什么通常一台服务器只能有一张数字证书的原因。
* 对于虚拟主机的用户来说，这当然很不方便。2006年，TLS协议加入了一个 *Server Name Indication* 扩展，允许客户端向服务器提供它所请求的域名。

. 服务器回应（SeverHello）
+
.回应的内容
****
* 确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信
* 一个服务器生成的随机数，稍后用于生成 *对话密钥*
* 确认使用的加密方法，比如RSA公钥加密
* 服务器证书(只包含公钥)
* (如果服务器需要确认客户端的身份)要求客户端提供 *客户端证书*
****

. 客户端回应
+
.回应的内容
****
* 一个随机数(该随机数用服务器公钥加密，防止被窃听)
* 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送
* (如果服务器要求提供客户端证书)客户端证书
* 客户端握手结束通知，表示客户端的握手阶段已经结束(这一项同时也是前面发送的所有内容的hash值，用来供服务器校验)
****
* 客户端收到服务器回应以后，首先验证服务器证书，验证不通过会提示警告信息给用户
* 至此，客户端和服务器就同时有了三个随机数(为什么要3个随机数？协议不信任每个主机都能生成完全随机的随机数，这3个随机数再加上非对称算法本身一般会有一个随机数，以此来生成密钥就比较安全了)
* 客户端在此时生成 *对话密钥*，将用于加解密通信的内容

. 服务器的最后回应
+
.回应的内容
****
* 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。
* 服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。
****
* 服务器收到客户端回应后，首先生成本次会话所用的 *会话密钥* ，然后才向客户端发送上面的内容

== 参考资料
https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html[SSL/TLS协议运行机制的概述(阮一峰)]